{
  "S101": "Use of assert detected",
  "S102": "Use of exec detected",
  "S103": "Setting permissive file permissions with os.chmod",
  "S104": "Possible binding to all interfaces",
  "S105": "Possible hardcoded password in string assignment",
  "S106": "Possible hardcoded password assigned to function argument",
  "S107": "Possible hardcoded password in function default value",
  "S108": "Insecure use of temporary file or directory",
  "S110": "Silent failure: try-except-pass used",
  "S112": "Silent continue: try-except-continue used",
  "S113": "Request made without timeout",
  "S201": "Flask app running with debug=True",
  "S202": "Unsafe use of tarfile.extractall()",
  "S301": "Use of pickle or similar unsafe deserialization module",
  "S302": "Use of marshal module is unsafe for deserialization",
  "S303": "Use of insecure hash function (e.g. MD5, SHA1)",
  "S304": "Use of insecure cipher, replace with a secure one like AES",
  "S305": "Use of insecure cipher mode, replace with secure mode (CBC, CTR)",
  "S306": "Use of deprecated and insecure mktemp() function",
  "S307": "Use of insecure eval(), consider using ast.literal_eval",
  "S308": "mark_safe may expose XSS vulnerabilities",
  "S310": "Audit URL open calls for insecure schemes like file:",
  "S311": "Use of non-cryptographic pseudo-random generator for secure operations",
  "S312": "Use of Telnet, considered insecure",
  "S313": "Use of xml.etree.cElementTree for untrusted data is unsafe",
  "S314": "Use of xml.etree.ElementTree for untrusted data is unsafe",
  "S315": "Use of xml.dom.expatreader for untrusted data is unsafe",
  "S316": "Use of xml.dom.expatbuilder for untrusted data is unsafe",
  "S317": "Use of xml.sax for untrusted data is unsafe",
  "S318": "Use of xml.dom.minidom for untrusted data is unsafe",
  "S319": "Use of xml.dom.pulldom for untrusted data is unsafe",
  "S320": "Use of lxml for untrusted data is unsafe",
  "S321": "Use of FTP-related libraries, which are insecure",
  "S323": "Use of _create_unverified_context disables certificate verification",
  "S324": "Insecure hash function used in hashlib (e.g. MD5, SHA1)",
  "S401": "Import of telnetlib, which is insecure",
  "S402": "Import of ftplib, which is insecure",
  "S403": "Import of pickle-like modules which are unsafe",
  "S404": "Import of subprocess module may indicate insecure usage",
  "S405": "Import of xml.etree, vulnerable to XML attacks",
  "S406": "Import of xml.sax, vulnerable to XML attacks",
  "S407": "Import of xml.dom.expatbuilder, vulnerable to XML attacks",
  "S408": "Import of xml.dom.minidom, vulnerable to XML attacks",
  "S409": "Import of xml.dom.pulldom, vulnerable to XML attacks",
  "S410": "Import of lxml, vulnerable to XML attacks",
  "S411": "Import of xmlrpc, vulnerable to XML attacks",
  "S412": "Use of CGI environments vulnerable to httpoxy attacks",
  "S413": "Use of pycrypto library with known vulnerabilities",
  "S415": "Import of IPMI-related module; prefer encrypted alternatives",
  "S501": "Request made with verify=False, disabling SSL cert checks",
  "S502": "Use of insecure SSL protocol version",
  "S503": "Insecure SSL protocol set as function default",
  "S504": "ssl.wrap_socket used without specifying ssl_version",
  "S505": "Cryptographic key too short and considered weak",
  "S506": "Unsafe yaml.load used with non-safe loader",
  "S507": "Host key not verified in Paramiko",
  "S508": "Use of insecure SNMPv1 or SNMPv2",
  "S509": "Use of weak SNMPv3 configuration without encryption",
  "S601": "Possible shell injection via Paramiko",
  "S602": "subprocess.Popen with shell=True may be unsafe",
  "S603": "subprocess call without shell=True — check for untrusted input",
  "S604": "Function call with shell=True detected, potential injection risk",
  "S605": "Starting a process with a shell may be unsafe",
  "S606": "Starting a process without shell — check safety",
  "S607": "Process started with a partial path, may be ambiguous",
  "S608": "SQL query string construction may allow SQL injection",
  "S609": "Wildcard injection via `*` in shell commands",
  "S610": "Use of Django `.extra()` can lead to SQL injection",
  "S611": "Use of RawSQL in Django may allow SQL injection",
  "S612": "Use of logging.config.listen may expose insecure port",
  "S701": "jinja2 templates with autoescape=False are XSS-prone",
  "S702": "Mako templates may allow XSS rendering",
  "S704": "Unsafe use of HTML/markup function detected",
 "AIR001": "Task variable name should match the task_id",
  "AIR002": "DAG should have an explicit schedule argument",
  "AIR301": "{deprecated} is removed in Airflow 3.0",
  "AIR302": "{deprecated} is removed in Airflow 3.0",
  "AIR311": "{deprecated} is removed in Airflow 3.0; still works but will be removed later",
  "AIR312": "{deprecated} is removed in Airflow 3.0",
  "ERA001": "Found commented-out code",
  "FAST001": "FastAPI route has redundant response_model argument",
  "FAST002": "FastAPI dependency missing Annotated",
  "FAST003": "Path parameter appears in route but not in function signature",
  "YTT101": "Use sys.version_info instead of sys.version[:3]",
  "YTT102": "Use sys.version_info instead of sys.version[2]",
  "YTT103": "Compare sys.version_info instead of sys.version string",
  "YTT201": "Replace sys.version_info[0] == 3 with >= for Python 4",
  "YTT202": "Replace six.PY3 check with not six.PY2 for Python 4",
  "YTT203": "Compare sys.version_info directly to tuple, not version_info[1]",
  "YTT204": "Compare sys.version_info directly to tuple, not .minor",
  "YTT301": "Use sys.version_info instead of sys.version[0]",
  "YTT302": "Compare sys.version_info instead of sys.version string (Python 10)",
  "YTT303": "Use sys.version_info instead of sys.version[:1]",
  "ANN001": "Missing type annotation for function argument",
  "ANN002": "Missing type annotation for *args",
  "ANN003": "Missing type annotation for **kwargs",
  "ANN101": "Missing type annotation for self in method",
  "ANN102": "Missing type annotation for cls in classmethod",
  "ANN201": "Missing return type for public function",
  "ANN202": "Missing return type for private function",
  "ANN204": "Missing return type for special method",
  "ANN205": "Missing return type for static method",
  "ANN206": "Missing return type for classmethod",
  "ANN401": "Use of dynamically typed expressions (typing.Any) is disallowed",
  "ASYNC100": "Async context (with ...) lacks await; timeout ineffective",
  "ASYNC105": "Async call not immediately awaited",
  "ASYNC109": "Async function defined with a timeout parameter",
  "ASYNC110": "Use Event instead of sleep in async busy-wait loop",
  "ASYNC115": "Use lowlevel.checkpoint() instead of sleep(0)",
  "ASYNC116": "Use sleep_forever() for sleeps longer than 24 hours",
  "ASYNC210": "Blocking HTTP call made in async function",
  "ASYNC220": "Blocking subprocess creation in async function",
  "ASYNC221": "Blocking process run in async function",
  "ASYNC222": "Blocking wait for process in async function",
  "ASYNC230": "Blocking open() call in async function",
  "ASYNC251": "Blocking time.sleep in async function",
  "BLE001": "Do not catch blind exception: {name}",
  "FBT001": "Boolean-typed positional argument in function definition",
  "FBT002": "Boolean default positional argument in function definition",
  "FBT003": "Boolean positional value in function call",
  "B002": "Python does not support the unary prefix increment operator (++).",
  "B003": "Assigning to os.environ doesn't clear the environment.",
  "B004": "Using hasattr(x, \"__call__\") to test if x is callable is unreliable. Use callable(x) instead.",
  "B005": "Using .strip() with multi-character strings is misleading.",
  "B006": "Do not use mutable data structures for argument defaults.",
  "B007": "Loop control variable {name} not used within loop body.",
  "B008": "Do not perform function call {name} in argument defaults; do it within the function instead.",
  "B009": "Do not call getattr with a constant attribute value; use normal property access.",
  "B010": "Do not call setattr with a constant attribute value; use normal property access.",
  "B011": "Do not assert False; raise AssertionError() instead.",
  "B012": "{name} inside finally blocks causes exceptions to be silenced.",
  "B013": "Length-one tuple literal is redundant in exception handlers.",
  "B014": "Exception handler with duplicate exception: {name}.",
  "B015": "Pointless comparison; maybe you meant assignment or should remove it.",
  "B016": "Cannot raise a literal; did you mean to raise an Exception?",
  "B017": "Do not assert blind exception: {exception}.",
  "B018": "Found useless expression; assign it or remove it.",
  "B019": "Use of functools cache decorators on methods can lead to memory leaks.",
  "B020": "Loop control variable {name} overrides iterable it iterates.",
  "B021": "f-string used as docstring, which will be interpreted as a joined string.",
  "B022": "No arguments passed to contextlib.suppress; context manager is redundant.",
  "B023": "Function definition does not bind loop variable {name}.",
  "B024": "{name} is an abstract base class with no abstract methods or properties.",
  "B025": "Try-except block with duplicate exception {name}.",
  "B026": "Star-arg unpacking after keyword argument is discouraged.",
  "B027": "{name} is empty method in abstract base class without abstract decorator.",
  "B028": "No explicit stacklevel keyword argument found.",
  "B029": "Using except* () with empty tuple does not catch anything; add exceptions to handle.",
  "B030": "Except* handlers should only be exception classes or tuples of exception classes.",
  "B031": "Using itertools.groupby() generator more than once has no effect after first use.",
  "B032": "Possible unintentional type annotation using :, did you mean =?",
  "B033": "Sets should not contain duplicate item {value}.",
  "B034": "{method} should pass {param_name} and flags as keyword arguments to avoid confusion.",
  "B035": "Dictionary comprehension uses static key: {key}.",
  "B039": "Do not use mutable data structures for ContextVar defaults.",
  "B901": "Using yield and return {value} in a generator can lead to confusing behavior.",
  "B903": "Class could be dataclass or namedtuple.",
  "B904": "Within except* clause, raise exceptions with 'raise ... from err' or 'from None'.",
  "B905": "zip() called without explicit strict= parameter.",
  "B909": "Mutation to loop iterable {name} during iteration.",
  "B911": "itertools.batched() called without explicit strict parameter.",
  "A001": "Variable {name} is shadowing a Python builtin.",
  "A002": "Function argument {name} is shadowing a Python builtin.",
  "A003": "Python builtin is shadowed by class attribute {name} from {row}.",
  "A004": "Import {name} is shadowing a Python builtin.",
  "A005": "Module {name} shadows a Python standard-library module.",
  "A006": "Lambda argument {name} is shadowing a Python builtin.",
  "COM812": "Trailing comma missing.",
  "COM818": "Trailing comma on bare tuple prohibited.",
  "COM819": "Trailing comma prohibited.",
  "C400": "Unnecessary generator, rewrite using list().",
  "C401": "Unnecessary generator, rewrite using set().",
  "C402": "Unnecessary generator, rewrite as a dict comprehension.",
  "C403": "Unnecessary list comprehension, rewrite as a set comprehension.",
  "C404": "Unnecessary list comprehension, rewrite as a dict comprehension.",
  "C405": "Unnecessary {kind} literal, rewrite as a set literal.",
  "C406": "Unnecessary {obj_type} literal, rewrite as a dict literal.",
  "C408": "Unnecessary {kind}() call, rewrite as a literal.",
  "C409": "Unnecessary list literal passed to tuple(), rewrite as a tuple literal.",
  "C410": "Unnecessary list literal passed to list(), remove outer list() call.",
  "C411": "Unnecessary list() call, remove outer list() call.",
  "C413": "Unnecessary {func}() call around sorted().",
  "C414": "Unnecessary {inner}() call within {outer}().",
  "C415": "Unnecessary subscript reversal of iterable within {func}().",
  "C416": "Unnecessary {kind} comprehension, rewrite using {kind}().",
  "C417": "Unnecessary map() usage, rewrite using a {object_type}.",
  "C418": "Unnecessary dict {kind} passed to dict(), remove outer dict() call.",
  "C419": "Unnecessary list comprehension.",
  "C420": "Unnecessary dict comprehension for iterable; use dict.fromkeys instead.",
  "CPY001": "Missing copyright notice at top of file.",
  "DTZ001": "datetime.datetime() called without a tzinfo argument.",
  "DTZ002": "datetime.datetime.today() used.",
  "DTZ003": "datetime.datetime.utcnow() used.",
  "DTZ004": "datetime.datetime.utcfromtimestamp() used.",
  "DTZ005": "datetime.datetime.now() called without a tz argument.",
  "DTZ006": "datetime.datetime.fromtimestamp() called without a tz argument.",
  "DTZ007": "Naive datetime constructed using datetime.datetime.strptime() without %z.",
  "DTZ011": "datetime.date.today() used.",
  "DTZ012": "datetime.date.fromtimestamp() used.",
  "DTZ901": "Use of datetime.datetime.{min_max} without timezone information.",
  "T100": "Trace found: {name} used.",
  "DJ001": "Avoid using null=True on string-based fields such as {field_name}.",
  "DJ003": "Avoid passing locals() as context to a render function.",
  "DJ006": "Do not use exclude with ModelForm, use fields instead.",
  "DJ007": "Do not use __all__ with ModelForm, use fields instead.",
  "DJ008": "Model does not define __str__ method.",
  "DJ012": "Order of model's inner classes, methods, and fields does not follow Django Style Guide: {element_type} should come before {prev_element_type}.",
  "DJ013": "@receiver decorator must be on top of all other decorators.",
  "EM101": "Exception must not use a string literal, assign to variable first.",
  "EM102": "Exception must not use an f-string literal, assign to variable first.",
  "EM103": "Exception must not use a .format() string directly, assign to variable first.",
  "EXE001": "Shebang is present but file is not executable.",
  "EXE002": "File is executable but no shebang is present.",
  "EXE003": "Shebang should contain python, pytest, or uv run.",
  "EXE004": "Avoid whitespace before shebang.",
  "EXE005": "Shebang should be at the beginning of the file.",
  "FIX001": "Line contains FIXME; consider resolving the issue.",
  "FIX002": "Line contains TODO; consider resolving the issue.",
  "FIX003": "Line contains XXX; consider resolving the issue.",
  "FIX004": "Line contains HACK; consider resolving the issue.",
  "FA100": "Add 'from __future__ import annotations' to simplify {name}.",
  "FA102": "Missing 'from __future__ import annotations', but uses {reason}.",
  "INT001": "f-string is resolved before gettext function call; consider _('string %s') % arg.",
  "INT002": "format method argument resolved before gettext call; consider _('string %s') % arg.",
  "INT003": "printf-style format resolved before gettext call; consider _('string %s') % arg.",
  "ISC001": "Implicitly concatenated string literals on one line.",
  "ISC002": "Implicitly concatenated string literals over multiple lines.",
  "ISC003": "Explicitly concatenated string should be implicitly concatenated.",
  "ICN001": "{name} should be imported as {asname}.",
  "ICN002": "{name} should not be imported as {asname}.",
  "ICN003": "Members of {name} should not be imported explicitly.",
  "LOG001": "Use logging.getLogger() to instantiate loggers.",
  "LOG002": "Use __name__ with logging.getLogger().",
  "LOG004": ".exception() call outside exception handlers.",
  "LOG007": "Use of logging.exception with falsy exc_info.",
  "LOG009": "Use of undocumented logging.WARN constant.",
  "LOG014": "exc_info= used outside exception handlers.",
  "LOG015": "{}() call on root logger.",
  "G001": "Logging statement uses str.format.",
  "G002": "Logging statement uses % formatting.",
  "G003": "Logging statement uses + string concatenation.",
  "G004": "Logging statement uses f-string.",
  "G010": "Logging statement uses warn instead of warning.",
  "G101": "Logging statement uses an extra field that clashes with a LogRecord field: {key}.",
  "G201": "Logging .exception(...) should be used instead of .error(..., exc_info=True).",
  "G202": "Logging statement has redundant exc_info.",
  "INP001": "File {filename} is part of an implicit namespace package. Add an __init__.py.",
  "PIE790": "Unnecessary pass statement.",
  "PIE794": "Class field {name} is defined multiple times.",
  "PIE796": "Enum contains duplicate value: {value}.",
  "PIE800": "Unnecessary spread **.",
  "PIE804": "Unnecessary dict kwargs.",
  "PIE807": "Prefer {container} over useless lambda.",
  "PIE808": "Unnecessary start argument in range.",
  "PIE810": "Call {attr} once with a tuple.",
  "T201": "print statement found.",
  "T203": "pprint statement found.",
  "PYI001": "Name of private {kind} must start with _.",
  "PYI002": "if test must be a simple comparison against sys.platform or sys.version_info.",
  "PYI003": "Unrecognized sys.version_info check.",
  "PYI004": "Version comparison must use only major and minor version.",
  "PYI005": "Version comparison must be against a length-{expected_length} tuple.",
  "PYI006": "Use < or >= for sys.version_info comparisons.",
  "PYI007": "Unrecognized sys.platform check.",
  "PYI008": "Unrecognized platform {platform}.",
  "PYI009": "Empty stub body should contain ..., not pass.",
  "PYI010": "Function body must contain only ....",
  "PYI011": "Only simple default values allowed for typed arguments.",
  "PYI012": "Class body must not contain pass.",
  "PYI013": "Non-empty class body must not contain ....",
  "PYI014": "Only simple default values allowed for arguments.",
  "PYI015": "Only simple default values allowed for assignments.",
  "PYI016": "Duplicate union member {}.",
  "PYI017": "Stubs should not contain assignments to attributes or multiple targets.",
  "PYI018": "Private {type_var_like_kind} {type_var_like_name} is never used.",
  "PYI019": "Use Self instead of custom TypeVar {}.",
  "PYI020": "Quoted annotations should not be included in stubs.",
  "PYI021": "Docstrings should not be included in stubs.",
  "PYI024": "Use typing.NamedTuple instead of collections.namedtuple.",
  "PYI025": "Use from collections.abc import Set as AbstractSet to avoid confusion with set builtin.",
  "PYI026": "Use {module}.TypeAlias for type alias, e.g., {name}: TypeAlias = {value}.",
  "PYI029": "Defining {name} in a stub is almost always redundant.",
  "PYI030": "Multiple literal members in a union. Use a single literal, e.g., Literal[{}].",
  "PYI032": "Prefer object to Any for the second parameter to {method_name}.",
  "PYI033": "Don't use type comments in stub files.",
  "PYI034": "__new__ methods usually return self at runtime.",
  "PYI035": "{name} in a stub file must have a value, same as runtime semantics.",
  "PYI036": "Star-args in {method_name} should be annotated with object.",
  "PYI041": "Use {supertype} instead of {subtype} | {supertype}.",
  "PYI042": "Type alias {name} should be CamelCase.",
  "PYI043": "Private type alias {name} should not be suffixed with T.",
  "PYI044": "'from __future__ import annotations' has no effect in stub files.",
  "PYI045": "__aiter__ methods should return AsyncIterator, not AsyncIterable.",
  "PYI046": "Private protocol {name} is never used.",
  "PYI047": "Private TypeAlias {name} is never used.",
  "PYI048": "Function body must contain exactly one statement.",
  "PYI049": "Private TypedDict {name} is never used.",
  "PYI050": "Prefer {module}.Never over NoReturn for argument annotations.",
  "PYI051": "Literal[{literal}] is redundant in a union with {builtin_type}.",
  "PYI052": "Need type annotation for {name}.",
  "PYI053": "String and bytes literals longer than 50 characters are not permitted.",
  "PYI054": "Numeric literals longer than 10 characters are not permitted.",
  "PYI055": "Multiple type members in a union. Combine them into one.",
  "PYI056": "Calling .{name}() on __all__ may not be supported by all type checkers.",
  "PYI057": "Do not use {origin}.ByteString, deprecated with unclear semantics.",
  "PYI058": "Use {return_type} as return value for simple {method} methods.",
  "PYI059": "Generic[] should always be the last base class.",
  "PYI061": "Use None rather than Literal[None].",
  "PYI062": "Duplicate literal member {}.",
  "PYI063": "Use PEP 570 syntax for positional-only parameters.",
  "PYI064": "Final[Literal[{literal}]] can be replaced with bare Final.",
  "PYI066": "Put branches for newer Python versions first when branching on sys.version_info.",
  "PT001": "Use @pytest.fixture{expected} syntax over incorrect parentheses style.",
  "PT002": "Fixture configuration should use keyword arguments, not positional args.",
  "PT003": "scope='function' is implied in @pytest.fixture(), no need to specify.",
  "PT004": "Fixture returns nothing, add a leading underscore to its name.",
  "PT005": "Fixture returns a value, remove the leading underscore from its name.",
  "PT006": "Wrong type passed to first argument of pytest.mark.parametrize.",
  "PT007": "Wrong type for values in pytest.mark.parametrize.",
  "PT008": "Use return_value= instead of patching with lambda in mocks.",
  "PT009": "Use plain assert instead of unittest-style assertions.",
  "PT010": "Specify expected exception in pytest.raises().",
  "PT011": "pytest.raises() exception is too broad, narrow with match or specific exception.",
  "PT012": "pytest.raises() block should contain a single simple statement.",
  "PT013": "Import pytest using 'import pytest', not alternative syntax.",
  "PT014": "Duplicate test case in pytest.mark.parametrize at given index.",
  "PT015": "Assertion always fails; replace with pytest.fail().",
  "PT016": "pytest.fail() called without a message.",
  "PT017": "Assertion in except block; use pytest.raises() instead.",
  "PT018": "Composite assertion should be split into multiple simpler assertions.",
  "PT019": "Fixture without value used as parameter; use @pytest.mark.usefixtures instead.",
  "PT020": "@pytest.yield_fixture is deprecated; use @pytest.fixture instead.",
  "PT021": "Use yield instead of request.addfinalizer for fixture finalizers.",
  "PT022": "No teardown in fixture; use return instead of yield.",
  "PT023": "Use correct parentheses style in @pytest.mark.{mark_name} decorator.",
  "PT024": "pytest.mark.asyncio is unnecessary on fixtures.",
  "PT025": "pytest.mark.usefixtures has no effect on fixtures.",
  "PT026": "pytest.mark.usefixtures used without parameters is useless.",
  "PT027": "Use pytest.raises() instead of unittest-style exception assertions.",
  "PT028": "Test function parameter has a default argument.",
  "PT029": "Set expected warning in pytest.warns().",
  "PT030": "pytest.warns() warning is too broad; narrow with match or specific warning.",
  "PT031": "pytest.warns() block should contain a single simple statement.",
  "Q000": "Use double quotes instead of single quotes for inline strings.",
  "Q001": "Use double quotes instead of single quotes for multiline strings.",
  "Q002": "Use double quotes instead of single quotes for docstrings.",
  "Q003": "Change outer quotes to avoid escaping inner quotes.",
  "Q004": "Remove unnecessary escape on inner quote character.",
  "RSE102": "Avoid unnecessary parentheses when raising exceptions.",
  "RET501": "Do not explicitly return None if it's the only possible return value.",
  "RET502": "Do not implicitly return None in functions able to return non-None values.",
  "RET503": "Explicit return missing in functions able to return non-None values.",
  "RET504": "Unnecessary assignment before return statement.",
  "RET505": "Unnecessary else after a return statement.",
  "RET506": "Unnecessary else after a raise statement.",
  "RET507": "Unnecessary else after a continue statement.",
  "RET508": "Unnecessary else after a break statement.",
  "SLF001": "Accessing private member: {access}.",
  "SIM101": "Multiple isinstance calls for {name}, merge into one call.",
  "SIM102": "Use a single if statement instead of nested ifs.",
  "SIM103": "Return the boolean condition {condition} directly.",
  "SIM105": "Use contextlib.suppress({exception}) instead of try-except-pass.",
  "SIM107": "Avoid return statements in try-except-finally blocks.",
  "SIM108": "Use a ternary operator instead of if-else block.",
  "SIM109": "Use tuple comparison instead of multiple equality checks.",
  "SIM110": "Use {replacement} instead of for loop.",
  "SIM112": "Use capitalized environment variable {expected} instead of {actual}.",
  "SIM113": "Use enumerate() for index variable {index} in for loop.",
  "SIM114": "Combine if branches with logical or operator.",
  "SIM115": "Use context manager for opening files.",
  "SIM116": "Use dict lookup instead of consecutive if statements.",
  "SIM117": "Use a single with statement with multiple contexts instead of nested withs.",
  "SIM118": "Use key {operator} dict instead of key {operator} dict.keys().",
  "SIM201": "Use {left} != {right} instead of not {left} == {right}.",
  "SIM202": "Use {left} == {right} instead of not {left} != {right}.",
  "SIM208": "Use {expr} instead of double negation.",
  "SIM210": "Remove unnecessary 'True if ... else False'.",
  "SIM211": "Use not ... instead of 'False if ... else True'.",
  "SIM212": "Simplify ternary expression with swapped arms.",
  "SIM220": "Use False instead of '{name} and not {name}'.",
  "SIM221": "Use True instead of '{name} or not {name}'.",
  "SIM222": "Use {expr} instead of {replaced}.",
  "SIM223": "Use {expr} instead of {replaced}.",
  "SIM300": "Avoid Yoda conditions.",
  "SIM401": "Use dict.get() instead of if block.",
  "SIM905": "Consider list literal instead of str.split().",
  "SIM910": "Use {expected} instead of {actual} in dict.get().",
  "SIM911": "Use {expected} instead of {actual} when zipping dict keys and values.",
  "SLOT000": "Subclasses of str should define __slots__.",
  "SLOT001": "Subclasses of tuple should define __slots__.",
  "SLOT002": "Subclasses of namedtuple should define __slots__.",
  "TID251": "{name} is banned: {message}.",
  "TID252": "Prefer absolute imports over relative imports from parent modules.",
  "TID253": "{name} is banned at the module level.",
  "TD001": "Invalid TODO tag: {tag}.",
  "TD002": "Missing author in TODO; use # TODO(<author_name>): ... or # TODO @<author_name>: ...",
  "TD003": "Missing issue link for this TODO.",
  "TD004": "Missing colon in TODO.",
  "TD005": "Missing issue description after TODO.",
  "TD006": "TODO tag should be capitalized as TODO, not {tag}.",
  "TD007": "Missing space after colon in TODO.",
  "TC001": "Move application import {name} into a type-checking block.",
  "TC002": "Move third-party import {name} into a type-checking block.",
  "TC003": "Move standard library import {name} into a type-checking block.",
  "TC004": "Move import {qualified_name} out of type-checking block; used at runtime.",
  "TC005": "Empty type-checking block found.",
  "TC006": "Add quotes to type expression in typing.cast().",
  "TC007": "Add quotes to type alias.",
  "TC008": "Remove quotes from type alias.",
  "TC010": "Invalid string member in X | Y-style union type.",
  "ARG001": "Unused function argument: {name}.",
  "ARG002": "Unused method argument: {name}.",
  "ARG003": "Unused class method argument: {name}.",
  "ARG004": "Unused static method argument: {name}.",
  "ARG005": "Unused lambda argument: {name}.",
  "PTH100": "os.path.abspath() should be replaced by Path.resolve().",
  "PTH101": "os.chmod() should be replaced by Path.chmod().",
  "PTH102": "os.mkdir() should be replaced by Path.mkdir().",
  "PTH103": "os.makedirs() should be replaced by Path.mkdir(parents=True).",
  "PTH104": "os.rename() should be replaced by Path.rename().",
  "PTH105": "os.replace() should be replaced by Path.replace().",
  "PTH106": "os.rmdir() should be replaced by Path.rmdir().",
  "PTH107": "os.remove() should be replaced by Path.unlink().",
  "PTH108": "os.unlink() should be replaced by Path.unlink().",
  "PTH109": "os.getcwd() should be replaced by Path.cwd().",
  "PTH110": "os.path.exists() should be replaced by Path.exists().",
  "PTH111": "os.path.expanduser() should be replaced by Path.expanduser().",
  "PTH112": "os.path.isdir() should be replaced by Path.is_dir().",
  "PTH113": "os.path.isfile() should be replaced by Path.is_file().",
  "PTH114": "os.path.islink() should be replaced by Path.is_symlink().",
  "PTH115": "os.readlink() should be replaced by Path.readlink().",
  "PTH116": "os.stat() should be replaced by Path.stat(), Path.owner(), or Path.group().",
  "PTH117": "os.path.isabs() should be replaced by Path.is_absolute().",
  "PTH118": "os.path.join() should be replaced by Path with / operator.",
  "PTH119": "os.path.basename() should be replaced by Path.name.",
  "PTH120": "os.path.dirname() should be replaced by Path.parent.",
  "PTH121": "os.path.samefile() should be replaced by Path.samefile().",
  "PTH122": "os.path.splitext() should be replaced by Path.suffix, Path.stem, and Path.parent.",
  "PTH123": "open() should be replaced by Path.open().",
  "PTH124": "py.path is deprecated; use pathlib instead.",
  "PTH201": "Do not pass current directory explicitly to Path().",
  "PTH202": "os.path.getsize should be replaced by Path.stat().st_size.",
  "PTH203": "os.path.getatime should be replaced by Path.stat().st_atime.",
  "PTH204": "os.path.getmtime should be replaced by Path.stat().st_mtime.",
  "PTH205": "os.path.getctime should be replaced by Path.stat().st_ctime.",
  "PTH206": "Replace .split(os.sep) with Path.parts.",
  "PTH207": "Replace {function} with Path.glob or Path.rglob.",
  "PTH208": "Use pathlib.Path.iterdir() instead of os.listdir().",
  "PTH210": "Invalid suffix passed to .with_suffix().",
  "PTH211": "os.symlink should be replaced by Path.symlink_to().",
  "FLY002": "Consider using f-string instead of string join.",
  "I001": "Import block is unsorted or improperly formatted.",
  "I002": "Missing required import: {name}.",
  "C901": "{name} is too complex ({complexity} > {max_complexity}).",
  "NPY001": "np.{type_name} is deprecated; use built-in type instead.",
  "NPY002": "Replace legacy np.random.{method_name} with np.random.Generator.",
  "NPY003": "np.{existing} is deprecated; use np.{replacement} instead.",
  "NPY201": "np.{existing} will be removed in NumPy 2.0; see migration guide.",
  "PD002": "Avoid inplace=True; it has inconsistent behavior.",
  "PD003": ".isna() is preferred over .isnull().",
  "PD004": ".notna() is preferred over .notnull().",
  "PD007": ".ix is deprecated; use .loc or .iloc.",
  "PD008": "Use .loc instead of .at; use NumPy for speed.",
  "PD009": "Use .iloc instead of .iat; use NumPy for speed.",
  "PD010": ".pivot_table is preferred over .pivot or .unstack.",
  "PD011": "Use .to_numpy() instead of .values.",
  "PD012": "Use .read_csv instead of .read_table for CSV files.",
  "PD013": ".melt is preferred over .stack.",
  "PD015": "Use DataFrame.merge() method instead of pd.merge function.",
  "PD901": "Avoid using generic variable name df for DataFrames.",
  "N804": "First argument of a class method should be named cls.",
  "N805": "First argument of a method should be named self.",
  "PERF101": "Avoid casting iterable to list before iteration.",
  "PERF102": "Use appropriate dict subset method when iterating.",
  "PERF401": "Use list comprehension to create transformed list.",
  "PERF403": "Use dictionary comprehension instead of for-loop.",
  "E111": "Indentation is not a multiple of {indent_width}.",
  "E112": "Expected an indented block.",
  "E113": "Unexpected indentation.",
  "E201": "Whitespace after '{symbol}' is not allowed.",
  "E202": "Whitespace before '{symbol}' is not allowed.",
  "E203": "Whitespace before '{symbol}' is not allowed.",
  "E204": "Whitespace after decorator is not allowed.",
  "E221": "Multiple spaces before operator.",
  "E222": "Multiple spaces after operator.",
  "E225": "Missing whitespace around operator.",
  "E226": "Missing whitespace around arithmetic operator.",
  "E241": "Multiple spaces after comma.",
  "E251": "Unexpected spaces around keyword/parameter equals.",
  "E252": "Missing whitespace around parameter equals.",
  "E261": "Too few spaces before inline comment; add at least two.",
  "E262": "No space after inline comment marker (#).",
  "E265": "Block comment should start with # and a space.",
  "E271": "Multiple spaces after keyword.",
  "E272": "Multiple spaces before keyword.",
  "E301": "Expected blank line between methods.",
  "E302": "Expected blank lines at top level.",
  "E303": "Too many blank lines.",
  "E304": "Blank lines found after decorator.",
  "E305": "Expected 2 blank lines after function or class definition.",
  "E306": "Expected blank line before nested definition.",
  "E401": "Multiple imports on one line.",
  "E402": "Module-level import not at top of file.",
  "E501": "Line-too-long",
  "E502": "Redundant backslash",
  "E701": "Multiple statements on one line (colon).",
  "E702": "Multiple statements on one line (semicolon).",
  "E703": "Unnecessary semicolon at statement end.",
  "E711": "Compare to None using 'is' or 'is not', not equality operators.",
  "E712": "Avoid comparing to True/False with ==; use condition directly.",
  "E713": "Use 'not in' instead of 'not ... in'.",
  "E714": "Use 'is not' instead of 'not ... is'.",
  "E721": "Use isinstance() or 'is' for type comparisons.",
  "E722": "Avoid bare except; specify exception type.",
  "E731": "Do not assign lambda expressions; use def instead.",
  "E741": "Ambiguous variable name: {name}",
  "E742": "Ambiguous class name: {name}",
  "E743": "Ambiguous function name: {name}",
  "E902": "{message}",
  "E999": "SyntaxError",
  "W191": "Indentation contains tabs",
  "W291": "Trailing whitespace",
  "W292": "No newline at end of file",
  "W293": "Blank line contains whitespace",
  "W391": "Too many newlines at end of {domain}",
  "W505": "Doc line too long ({width} > {limit})",
  "W605": "Invalid escape sequence: \\{ch}",
  "DOC201": "Return is not documented in docstring",
  "DOC202": "Docstring should not have a returns section because the function doesn't return anything",
  "DOC402": "Yield is not documented in docstring",
  "DOC403": "Docstring has a \"Yields\" section but the function doesn't yield anything",
  "DOC501": "Raised exception {id} missing from docstring",
  "DOC502": "Raised exception is not explicitly raised: {id}",
  "D100": "Missing docstring in public module",
  "D101": "Missing docstring in public class",
  "D102": "Missing docstring in public method",
  "D103": "Missing docstring in public function",
  "D104": "Missing docstring in public package",
  "D105": "Missing docstring in magic method",
  "D106": "Missing docstring in public nested class",
  "D107": "Missing docstring in __init__",
  "D200": "One-line docstring should fit on one line",
  "D201": "No blank lines allowed before function docstring (found {num_lines})",
  "D202": "No blank lines allowed after function docstring (found {num_lines})",
  "D203": "1 blank line required before class docstring",
  "D204": "1 blank line required after class docstring",
  "D205": "1 blank line required between summary line and description",
  "D206": "Docstring should be indented with spaces, not tabs",
  "D207": "Docstring is under-indented",
  "D208": "Docstring is over-indented",
  "D209": "Multi-line docstring closing quotes should be on a separate line",
  "D210": "No whitespaces allowed surrounding docstring text",
  "D211": "No blank lines allowed before class docstring",
  "D212": "Multi-line docstring summary should start at the first line",
  "D213": "Multi-line docstring summary should start at the second line",
  "D214": "Section is over-indented (\"{name}\")",
  "D215": "Section underline is over-indented (\"{name}\")",
  "D300": "Use triple double quotes \"\"\"",
  "D301": "Use r\"\"\" if any backslashes in a docstring",
  "D400": "First line should end with a period",
  "D401": "First line of docstring should be in imperative mood: \"{first_line}\"",
  "D402": "First line should not be the function's signature",
  "D403": "First word of the docstring should be capitalized: {} -> {}",
  "D404": "First word of the docstring should not be \"This\"",
  "D405": "Section name should be properly capitalized (\"{name}\")",
  "D406": "Section name should end with a newline (\"{name}\")",
  "D407": "Missing dashed underline after section (\"{name}\")",
  "D408": "Section underline should be in the line following the section's name (\"{name}\")",
  "D409": "Section underline should match the length of its name (\"{name}\")",
  "D410": "Missing blank line after section (\"{name}\")",
  "D411": "Missing blank line before section (\"{name}\")",
  "D412": "No blank lines allowed between a section header and its content (\"{name}\")",
  "D413": "Missing blank line after last section (\"{name}\")",
  "D414": "Section has no content (\"{name}\")",
  "D415": "First line should end with a period, question mark, or exclamation point",
  "D416": "Section name should end with a colon (\"{name}\")",
  "D417": "Missing argument description in the docstring for {definition}: {name}",
  "D418": "Function decorated with @overload shouldn't contain a docstring",
  "D419": "Docstring is empty",
  "F401": "{name} imported but unused; consider using importlib.util.find_spec to test for availability",
  "F402": "Import {name} from {row} shadowed by loop variable",
  "F403": "from {name} import * used; unable to detect undefined names",
  "F404": "from __future__ imports must occur at the beginning of the file",
  "F405": "{name} may be undefined, or defined from star imports",
  "F406": "from {name} import * only allowed at module level",
  "F407": "Future feature {name} is not defined",
  "F501": "%-format string has invalid format string: {message}",
  "F502": "%-format string expected mapping but got sequence",
  "F503": "%-format string expected sequence but got mapping",
  "F504": "%-format string has unused named argument(s): {message}",
  "F505": "%-format string is missing argument(s) for placeholder(s): {message}",
  "F506": "%-format string has mixed positional and named placeholders",
  "F507": "%-format string has {wanted} placeholder(s) but {got} substitution(s)",
  "F508": "%-format string * specifier requires sequence",
  "F509": "%-format string has unsupported format character {char}",
  "F521": ".format call has invalid format string: {message}",
  "F522": ".format call has unused named argument(s): {message}",
  "F523": ".format call has unused arguments at position(s): {message}",
  "F524": ".format call is missing argument(s) for placeholder(s): {message}",
  "F525": ".format string mixes automatic and manual numbering",
  "F541": "f-string without any placeholders",
  "F601": "Dictionary key literal {name} repeated",
  "F602": "Dictionary key {name} repeated",
  "F621": "Too many expressions in star-unpacking assignment",
  "F622": "Two starred expressions in assignment",
  "F631": "Assert test is a non-empty tuple, which is always True",
  "F632": "Use == to compare constant literals",
  "F633": "Use of >> is invalid with print function",
  "F634": "If test is a tuple, which is always True",
  "F701": "Break outside loop",
  "F702": "Continue not properly in loop",
  "F704": "{keyword} statement outside of a function",
  "F706": "Return statement outside of a function/method",
  "F707": "An except block as not the last exception handler",
  "F722": "Syntax error in forward annotation: {parse_error}",
  "F811": "Redefinition of unused {name} from {row}",
  "F821": "Undefined name {name}. {tip}",
  "F822": "Undefined name {name} in __all__",
  "F823": "Local variable {name} referenced before assignment",
  "F841": "Local variable {name} is assigned to but never used",
  "F842": "Local variable {name} is annotated but never used",
  "F901": "Raise NotImplemented should be raise NotImplementedError",
  "PGH001": "No builtin eval() allowed",
  "PGH002": "warn is deprecated in favor of warning",
  "PGH003": "Use specific rule codes when ignoring type issues",
  "PGH004": "Use specific rule codes when using noqa",
  "PGH005": "Mock method should be called: {name}",
  "PLC0105": "{kind} name \"{param_name}\" does not reflect its {variance}; consider renaming it to \"{replacement_name}\"",
  "PLC0131": "{kind} cannot be both covariant and contravariant",
  "PLC0132": "{kind} name {param_name} does not match assigned variable name {var_name}",
  "PLC0205": "Class __slots__ should be a non-string iterable",
  "PLC0206": "Extracting value from dictionary without calling .items()",
  "PLC0207": "Accessing only the first or last element of str.split() without setting maxsplit=1",
  "PLC0208": "Use a sequence type instead of a set when iterating over values",
  "PLC0414": "Import alias does not rename original package",
  "PLC0415": "import should be at the top-level of a file",
  "PLC1802": "len({expression}) used as condition without comparison",
  "PLC1901": "{existing} can be simplified to {replacement} as an empty string is falsey",
  "PLC2401": "{kind} name {name} contains a non-ASCII character",
  "PLC2403": "Module alias {name} contains a non-ASCII character",
  "PLC2701": "Private name import {name} from external module {module}",
  "PLC2801": "Unnecessary dunder call to {method}. {replacement}.",
  "PLC3002": "Lambda expression called directly. Execute the expression inline instead.",
  "PLE0100": "__init__ method is a generator",
  "PLE0101": "Explicit return in __init__",
  "PLE0115": "Name {name} is both nonlocal and global",
  "PLE0116": "continue not supported inside finally clause",
  "PLE0117": "Nonlocal name {name} found without binding",
  "PLE0118": "Name {name} is used prior to global declaration on {row}",
  "PLE0237": "Attribute {name} is not defined in class's __slots__",
  "PLE0241": "Duplicate base {base} for class {class}",
  "PLE0302": "The special method {} expects {}, {} {} given",
  "PLE0303": "__len__ does not return a non-negative integer",
  "PLE0304": "__bool__ does not return bool",
  "PLE0305": "__index__ does not return an integer",
  "PLE0307": "__str__ does not return str",
  "PLE0308": "__bytes__ does not return bytes",
  "PLE0309": "__hash__ does not return an integer",
  "PLE0604": "Invalid object in __all__, must contain only strings",
  "PLE0605": "Invalid format for __all__, must be tuple or list",
  "PLE0643": "Expression is likely to raise IndexError",
  "PLE0704": "Bare raise statement is not inside an exception handler",
  "PLE1132": "Repeated keyword argument: {duplicate_keyword}",
  "PLE1141": "Unpacking a dictionary in iteration without calling .items()",
  "PLE1142": "await should be used within an async function",
  "PLE1205": "Too many arguments for logging format string",
  "PLE1206": "Not enough arguments for logging format string",
  "PLE1300": "Unsupported format character '{format_char}'",
  "PLE1307": "Format type does not match argument type",
  "PLE1310": "String {strip} call contains duplicate characters (did you mean {removal}?)",
  "PLE1507": "Invalid type for initial os.getenv argument; expected str",
  "PLE1519": "@singledispatch decorator should not be used on methods",
  "PLE1520": "@singledispatchmethod decorator should not be used on non-method functions",
  "PLE1700": "yield from statement in async function; use async for instead",
  "PLE2502": "Contains control characters that can permit obfuscated code",
  "PLE2510": "Invalid unescaped character backspace, use \"\\b\" instead",
  "PLE2512": "Invalid unescaped character SUB, use \"\\x1A\" instead",
  "PLE2513": "Invalid unescaped character ESC, use \"\\x1B\" instead",
  "PLE2514": "Invalid unescaped character NUL, use \"\\0\" instead",
  "PLE2515": "Invalid unescaped character zero-width-space, use \"\\u200B\" instead",
  "PLE4703": "Iterated set {name} is modified within the for loop",
  "PLR0124": "Name compared with itself, consider replacing {actual}",
  "PLR0133": "Two constants compared in a comparison, consider replacing {left_constant} {op} {right_constant}",
  "PLR0202": "Class method defined without decorator",
  "PLR0203": "Static method defined without decorator",
  "PLR0206": "Cannot have defined parameters for properties",
  "PLR0402": "Use from {module} import {name} in lieu of alias",
  "PLR0904": "Too many public methods ({methods} > {max_methods})",
  "PLR0911": "Too many return statements ({returns} > {max_returns})",
  "PLR0912": "Too many branches ({branches} > {max_branches})",
  "PLR0913": "Too many arguments in function definition ({c_args} > {max_args})",
  "PLR0914": "Too many local variables ({current_amount}/{max_amount})",
  "PLR0915": "Too many statements ({statements} > {max_statements})",
  "PLR0916": "Too many Boolean expressions ({expressions} > {max_expressions})",
  "PLR0917": "Too many positional arguments ({c_pos}/{max_pos})",
  "PLR1701": "Merge isinstance calls: {expression}",
  "PLR1702": "Too many nested blocks ({nested_blocks} > {max_nested_blocks})",
  "PLR1704": "Redefining argument with the local name {name}",
  "PLR1706": "Consider using if-else expression",
  "PLR1711": "Useless return statement at end of function",
  "PLR1714": "Consider merging multiple comparisons: {expression}. Use a set if the elements are hashable.",
  "PLR1716": "Contains chained boolean comparison that can be simplified",
  "PLR1722": "Use sys.exit() instead of {name}",
  "PLR1730": "Replace if statement with {replacement}",
  "PLR1733": "Unnecessary lookup of dictionary value by key",
  "PLR1736": "List index lookup in enumerate() loop",
  "PLR2004": "Magic value used in comparison, consider replacing {value} with a constant variable",
  "PLR2044": "Line with empty comment",
  "PLR5501": "Use elif instead of else then if, to reduce indentation",
  "PLR6104": "Use {operator} to perform an augmented assignment directly",
  "PLR6201": "Use a set literal when testing for membership",
  "PLR6301": "Method {method_name} could be a function, class method, or static method",
  "PLW0108": "Lambda may be unnecessary; consider inlining inner function",
  "PLW0120": "else clause on loop without a break statement; remove the else and dedent its contents",
  "PLW0127": "Self-assignment of variable {name}",
  "PLW0128": "Redeclared variable {name} in assignment",
  "PLW0129": "Asserting on an empty string literal will never pass",
  "PLW0131": "Named expression used without context",
  "PLW0133": "Missing raise statement on exception",
  "PLW0177": "Comparing against a NaN value; use math.isnan instead",
  "PLW0211": "First argument of a static method should not be named {argument_name}",
  "PLW0244": "Slot {slot_name} redefined from base class {base}",
  "PLW0245": "super call is missing parentheses",
  "PLW0406": "Module {name} imports itself",
  "PLW0602": "Using global for {name} but no assignment is done",
  "PLW0603": "Using the global statement to update {name} is discouraged",
  "PLW0604": "global at module level is redundant",
  "PLW0642": "Reassigned {} variable in {method_type} method",
  "PLW0711": "Exception to catch is the result of a binary and operation",
  "PLW1501": "{mode} is not a valid mode for open",
  "PLW1507": "Shallow copy of os.environ via copy.copy(os.environ)",
  "PLW1508": "Invalid type for environment variable default; expected str or None",
  "PLW1509": "preexec_fn argument is unsafe when using threads",
  "PLW1510": "subprocess.run without explicit check argument",
  "PLW1514": "{function_name} in text mode without explicit encoding argument",
  "PLW1641": "Object does not implement __hash__ method",
  "PLW2101": "Threading lock directly created in with statement has no effect",
  "PLW2901": "Outer {outer_kind} variable {name} overwritten by inner {inner_kind} target",
  "PLW3201": "Dunder method {name} has no special meaning in Python 3",
  "PLW3301": "Nested {func} calls can be flattened",
  "UP001": "__metaclass__ = type is implied",
  "UP003": "Use {} instead of type(...)",
  "UP004": "Class {name} inherits from object",
  "UP005": "{alias} is deprecated, use {target}",
  "UP006": "Use {to} instead of {from} for type annotation",
  "UP007": "Use X | Y for type annotations",
  "UP008": "Use super() instead of super(__class__, self)",
  "UP009": "UTF-8 encoding declaration is unnecessary",
  "UP010": "Unnecessary __future__ import {import} for target Python version",
  "UP011": "Unnecessary parentheses to functools.lru_cache",
  "UP012": "Unnecessary call to encode as UTF-8",
  "UP013": "Convert {name} from TypedDict functional to class syntax",
  "UP014": "Convert {name} from NamedTuple functional to class syntax",
  "UP015": "Unnecessary mode argument",
  "UP017": "Use datetime.UTC alias",
  "UP018": "Unnecessary {literal_type} call (rewrite as a literal)",
  "UP019": "typing.Text is deprecated, use str",
  "UP020": "Use builtin open",
  "UP021": "universal_newlines is deprecated, use text",
  "UP022": "Prefer capture_output over sending stdout and stderr to PIPE",
  "UP023": "cElementTree is deprecated, use ElementTree",
  "UP024": "Replace aliased errors with OSError",
  "UP025": "Remove unicode literals from strings",
  "UP026": "mock is deprecated, use unittest.mock",
  "UP027": "Replace unpacked list comprehension with a generator expression",
  "UP028": "Replace yield over for loop with yield from",
  "UP029": "Unnecessary builtin import: {import}",
  "UP030": "Use implicit references for positional format fields",
  "UP031": "Use format specifiers instead of percent format",
  "UP032": "Use f-string instead of format call",
  "UP033": "Use @functools.cache instead of @functools.lru_cache(maxsize=None)",
  "UP034": "Avoid extraneous parentheses",
  "UP035": "Import from {target} instead: {names}",
  "UP036": "Version block is outdated for minimum Python version",
  "UP037": "Remove quotes from type annotation",
  "UP038": "Use X | Y in {} call instead of (X, Y)",
  "UP039": "Unnecessary parentheses after class definition",
  "UP040": "Type alias {name} uses {type_alias_method} instead of the type keyword",
  "UP041": "Replace aliased errors with TimeoutError",
  "UP042": "Class {name} inherits from both str and enum.Enum",
  "UP043": "Unnecessary default type arguments",
  "UP044": "Use * for unpacking",
  "UP045": "Use X | None for type annotations",
  "UP046": "Generic class {name} uses Generic subclass instead of type parameters",
  "UP047": "Generic function {name} should use type parameters",
  "UP049": "Generic {} uses private type parameters",
  "UP050": "Class {name} uses metaclass=type, which is redundant",
  "FURB101": "open and read should be replaced by Path({filename}).{suggestion}",
  "FURB103": "open and write should be replaced by Path({filename}).{suggestion}",
  "FURB105": "Unnecessary empty string passed to print",
  "FURB110": "Replace ternary if expression with or operator",
  "FURB113": "Use {suggestion} instead of repeatedly calling {name}.append()",
  "FURB116": "Replace {function_name} call with {display}",
  "FURB118": "Use operator.{operator} instead of defining a {target}",
  "FURB122": "Use of {}.write in a for loop",
  "FURB129": "Instead of calling readlines(), iterate over file object directly",
  "FURB131": "Prefer clear over deleting a full slice",
  "FURB132": "Use {suggestion} instead of check and remove",
  "FURB136": "Replace if expression with {min_max} call",
  "FURB140": "Use itertools.starmap instead of the generator",
  "FURB142": "Use of set.{}() in a for loop",
  "FURB145": "Prefer copy method over slicing",
  "FURB148": "enumerate value is unused, use for x in range(len(y)) instead",
  "FURB152": "Replace {literal} with math.{constant}",
  "FURB154": "Use of repeated consecutive {}",
  "FURB156": "Use of hardcoded string charset",
  "FURB157": "Verbose expression in Decimal constructor",
  "FURB161": "Use of bin({existing}).count('1')",
  "FURB162": "Unnecessary timezone replacement with zero offset",
  "FURB163": "Prefer math.{log_function}({arg}) over math.log with a redundant base",
  "FURB164": "Verbose method {method_name} in {constructor} construction",
  "FURB166": "Use of int with explicit base={base} after removing prefix",
  "FURB167": "Use of regular expression alias re.{}",
  "FURB168": "Prefer is operator over isinstance to check if an object is None",
  "FURB169": "When checking against None, use {} instead of comparison with type(None)",
  "FURB171": "Membership test against single-item container",
  "FURB177": "Prefer Path.cwd() over Path().resolve() for current-directory lookups",
  "FURB180": "Use of metaclass=abc.ABCMeta to define abstract base class",
  "FURB181": "Use of hashlib's .digest().hex()",
  "FURB187": "Use of assignment of reversed on list {name}",
  "FURB188": "Prefer str.removeprefix() over conditionally replacing with slice.",
  "FURB189": "Subclassing {subclass} can be error prone, use collections.{replacement} instead",
  "FURB192": "Prefer min over sorted() to compute the minimum value in a sequence",
  "RUF001": "String contains ambiguous {}. Did you mean {}?",
  "RUF002": "Docstring contains ambiguous {}. Did you mean {}?",
  "RUF003": "Comment contains ambiguous {}. Did you mean {}?",
  "RUF005": "Consider {expression} instead of concatenation",
  "RUF006": "Store a reference to the return value of {expr}.{method}",
  "RUF007": "Prefer itertools.pairwise() over zip() when iterating over successive pairs",
  "RUF008": "Do not use mutable default values for dataclass attributes",
  "RUF009": "Do not perform function call {name} in dataclass defaults",
  "RUF010": "Use explicit conversion flag",
  "RUF011": "Dictionary comprehension uses static key",
  "RUF012": "Mutable class attributes should be annotated with typing.ClassVar",
  "RUF013": "PEP 484 prohibits implicit Optional",
  "RUF015": "Prefer next({iterable}) over single element slice",
  "RUF016": "Slice in indexed access to type {value_type} uses type {index_type} instead of an integer",
  "RUF017": "Avoid quadratic list summation",
  "RUF018": "Avoid assignment expressions in assert statements",
  "RUF019": "Unnecessary key check before dictionary access",
  "RUF020": "{never_like} | T is equivalent to T",
  "RUF021": "Parenthesize a and b expressions when chaining and and or together, to make the precedence clear",
  "RUF022": "__all__ is not sorted",
  "RUF023": "{}.__slots__ is not sorted",
  "RUF024": "Do not pass mutable objects as values to dict.fromkeys",
  "RUF026": "default_factory is a positional-only argument to defaultdict",
  "RUF027": "Possible f-string without an f prefix",
  "RUF028": "This suppression comment is invalid because {}",
  "RUF029": "Function {name} is declared async, but doesn't await or use async features.",
  "RUF030": "print() call in assert statement is likely unintentional",
  "RUF031": "Use parentheses for tuples in subscripts",
  "RUF032": "Decimal() called with float literal argument",
  "RUF033": "__post_init__ method with argument defaults",
  "RUF034": "Useless if-else condition",
  "RUF035": "Unsafe use of {name} detected",
  "RUF036": "None not at the end of the type annotation.",
  "RUF037": "Unnecessary empty iterable within a deque call",
  "RUF038": "Literal[True, False, ...] can be replaced with Literal[...] | bool",
  "RUF039": "First argument to {call} is not raw string",
  "RUF040": "Non-string literal used as assert message",
  "RUF041": "Unnecessary nested Literal",
  "RUF043": "Pattern passed to match= contains metacharacters but is neither escaped nor raw",
  "RUF045": "Assignment without annotation found in dataclass body",
  "RUF046": "Value being cast to int is already an integer",
  "RUF047": "Empty else clause",
  "RUF048": "__version__ may contain non-integral-like elements",
  "RUF049": "An enum class should not be decorated with @dataclass",
  "RUF051": "Use pop instead of key in dict followed by del dict[key]",
  "RUF052": "Local dummy variable {} is accessed",
  "RUF053": "Class with type parameter list inherits from Generic",
  "RUF054": "Indented form feed",
  "RUF055": "Plain string pattern passed to re function",
  "RUF056": "Avoid providing a falsy fallback to dict.get() in boolean test positions. The default fallback None is already falsy.",
  "RUF057": "Value being rounded is already an integer",
  "RUF058": "itertools.starmap called on zip iterable",
  "RUF059": "Unpacked variable {name} is never used",
  "RUF060": "Unnecessary membership test on empty collection",
  "RUF061": "Use context-manager form of pytest.{}()",
  "RUF063": "Use {suggestion} instead of __dict__ access",
  "RUF064": "Non-octal mode",
  "RUF100": "Unused noqa directive",
  "RUF101": "{original} is a redirect to {target}",
  "RUF102": "Invalid rule code in # noqa: {}",
  "RUF200": "Failed to parse pyproject.toml: {message}",
  "TRY002": "Create your own exception",
  "TRY003": "Avoid specifying long messages outside the exception class",
  "TRY004": "Prefer TypeError exception for invalid type",
  "TRY200": "Use raise from to specify exception cause",
  "TRY201": "Use raise without specifying exception name",
  "TRY203": "Remove exception handler; error is immediately re-raised",
  "TRY300": "Consider moving this statement to an else block",
  "TRY301": "Abstract raise to an inner function",
  "TRY400": "Use logging.exception instead of logging.error",
  "TRY401": "Redundant exception object included in logging.exception call"
}